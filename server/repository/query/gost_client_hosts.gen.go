// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"server/model"
)

func newGostClientHost(db *gorm.DB, opts ...gen.DOOption) gostClientHost {
	_gostClientHost := gostClientHost{}

	_gostClientHost.gostClientHostDo.UseDB(db, opts...)
	_gostClientHost.gostClientHostDo.UseModel(&model.GostClientHost{})

	tableName := _gostClientHost.gostClientHostDo.TableName()
	_gostClientHost.ALL = field.NewAsterisk(tableName)
	_gostClientHost.Id = field.NewInt(tableName, "id")
	_gostClientHost.Code = field.NewString(tableName, "code")
	_gostClientHost.AllowEdit = field.NewInt(tableName, "allow_edit")
	_gostClientHost.AllowDel = field.NewInt(tableName, "allow_del")
	_gostClientHost.Version = field.NewInt64(tableName, "version")
	_gostClientHost.CreatedAt = field.NewTime(tableName, "created_at")
	_gostClientHost.UpdatedAt = field.NewTime(tableName, "updated_at")
	_gostClientHost.Name = field.NewString(tableName, "name")
	_gostClientHost.TargetIp = field.NewString(tableName, "target_ip")
	_gostClientHost.TargetPort = field.NewString(tableName, "target_port")
	_gostClientHost.TargetHttps = field.NewInt(tableName, "target_https")
	_gostClientHost.DomainPrefix = field.NewString(tableName, "domain_prefix")
	_gostClientHost.CustomDomain = field.NewString(tableName, "custom_domain")
	_gostClientHost.CustomCert = field.NewString(tableName, "custom_cert")
	_gostClientHost.CustomKey = field.NewString(tableName, "custom_key")
	_gostClientHost.CustomForceHttps = field.NewInt(tableName, "custom_force_https")
	_gostClientHost.CustomDomainMatcher = field.NewInt(tableName, "custom_domain_matcher")
	_gostClientHost.NodeCode = field.NewString(tableName, "node_code")
	_gostClientHost.ClientCode = field.NewString(tableName, "client_code")
	_gostClientHost.UserCode = field.NewString(tableName, "user_code")
	_gostClientHost.Enable = field.NewInt(tableName, "enable")
	_gostClientHost.Status = field.NewInt(tableName, "status")
	_gostClientHost.WhiteEnable = field.NewInt(tableName, "white_enable")
	_gostClientHost.WhiteList = field.NewString(tableName, "white_list")
	_gostClientHost.ChargingType = field.NewInt(tableName, "charging_type")
	_gostClientHost.Cycle = field.NewInt(tableName, "cycle")
	_gostClientHost.Amount = field.NewField(tableName, "amount")
	_gostClientHost.Limiter = field.NewInt(tableName, "limiter")
	_gostClientHost.RLimiter = field.NewInt(tableName, "r_limiter")
	_gostClientHost.CLimiter = field.NewInt(tableName, "c_limiter")
	_gostClientHost.ExpAt = field.NewInt64(tableName, "exp_at")
	_gostClientHost.Node = gostClientHostBelongsToNode{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Node", "model.GostNode"),
		Configs: struct {
			field.RelationField
			Node struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Node.Configs", "model.GostNodeConfig"),
			Node: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Node.Configs.Node", "model.GostNode"),
			},
		},
	}

	_gostClientHost.Client = gostClientHostBelongsToClient{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Client", "model.GostClient"),
		User: struct {
			field.RelationField
			BindEmail struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Client.User", "model.SystemUser"),
			BindEmail: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Client.User.BindEmail", "model.SystemUserEmail"),
			},
		},
	}

	_gostClientHost.User = gostClientHostBelongsToUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "model.SystemUser"),
	}

	_gostClientHost.fillFieldMap()

	return _gostClientHost
}

type gostClientHost struct {
	gostClientHostDo

	ALL                 field.Asterisk
	Id                  field.Int
	Code                field.String
	AllowEdit           field.Int
	AllowDel            field.Int
	Version             field.Int64
	CreatedAt           field.Time
	UpdatedAt           field.Time
	Name                field.String
	TargetIp            field.String
	TargetPort          field.String
	TargetHttps         field.Int
	DomainPrefix        field.String
	CustomDomain        field.String
	CustomCert          field.String
	CustomKey           field.String
	CustomForceHttps    field.Int
	CustomDomainMatcher field.Int
	NodeCode            field.String
	ClientCode          field.String
	UserCode            field.String
	Enable              field.Int
	Status              field.Int
	WhiteEnable         field.Int
	WhiteList           field.String
	ChargingType        field.Int
	Cycle               field.Int
	Amount              field.Field
	Limiter             field.Int
	RLimiter            field.Int
	CLimiter            field.Int
	ExpAt               field.Int64
	Node                gostClientHostBelongsToNode

	Client gostClientHostBelongsToClient

	User gostClientHostBelongsToUser

	fieldMap map[string]field.Expr
}

func (g gostClientHost) Table(newTableName string) *gostClientHost {
	g.gostClientHostDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gostClientHost) As(alias string) *gostClientHost {
	g.gostClientHostDo.DO = *(g.gostClientHostDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gostClientHost) updateTableName(table string) *gostClientHost {
	g.ALL = field.NewAsterisk(table)
	g.Id = field.NewInt(table, "id")
	g.Code = field.NewString(table, "code")
	g.AllowEdit = field.NewInt(table, "allow_edit")
	g.AllowDel = field.NewInt(table, "allow_del")
	g.Version = field.NewInt64(table, "version")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")
	g.Name = field.NewString(table, "name")
	g.TargetIp = field.NewString(table, "target_ip")
	g.TargetPort = field.NewString(table, "target_port")
	g.TargetHttps = field.NewInt(table, "target_https")
	g.DomainPrefix = field.NewString(table, "domain_prefix")
	g.CustomDomain = field.NewString(table, "custom_domain")
	g.CustomCert = field.NewString(table, "custom_cert")
	g.CustomKey = field.NewString(table, "custom_key")
	g.CustomForceHttps = field.NewInt(table, "custom_force_https")
	g.CustomDomainMatcher = field.NewInt(table, "custom_domain_matcher")
	g.NodeCode = field.NewString(table, "node_code")
	g.ClientCode = field.NewString(table, "client_code")
	g.UserCode = field.NewString(table, "user_code")
	g.Enable = field.NewInt(table, "enable")
	g.Status = field.NewInt(table, "status")
	g.WhiteEnable = field.NewInt(table, "white_enable")
	g.WhiteList = field.NewString(table, "white_list")
	g.ChargingType = field.NewInt(table, "charging_type")
	g.Cycle = field.NewInt(table, "cycle")
	g.Amount = field.NewField(table, "amount")
	g.Limiter = field.NewInt(table, "limiter")
	g.RLimiter = field.NewInt(table, "r_limiter")
	g.CLimiter = field.NewInt(table, "c_limiter")
	g.ExpAt = field.NewInt64(table, "exp_at")

	g.fillFieldMap()

	return g
}

func (g *gostClientHost) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gostClientHost) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 34)
	g.fieldMap["id"] = g.Id
	g.fieldMap["code"] = g.Code
	g.fieldMap["allow_edit"] = g.AllowEdit
	g.fieldMap["allow_del"] = g.AllowDel
	g.fieldMap["version"] = g.Version
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
	g.fieldMap["name"] = g.Name
	g.fieldMap["target_ip"] = g.TargetIp
	g.fieldMap["target_port"] = g.TargetPort
	g.fieldMap["target_https"] = g.TargetHttps
	g.fieldMap["domain_prefix"] = g.DomainPrefix
	g.fieldMap["custom_domain"] = g.CustomDomain
	g.fieldMap["custom_cert"] = g.CustomCert
	g.fieldMap["custom_key"] = g.CustomKey
	g.fieldMap["custom_force_https"] = g.CustomForceHttps
	g.fieldMap["custom_domain_matcher"] = g.CustomDomainMatcher
	g.fieldMap["node_code"] = g.NodeCode
	g.fieldMap["client_code"] = g.ClientCode
	g.fieldMap["user_code"] = g.UserCode
	g.fieldMap["enable"] = g.Enable
	g.fieldMap["status"] = g.Status
	g.fieldMap["white_enable"] = g.WhiteEnable
	g.fieldMap["white_list"] = g.WhiteList
	g.fieldMap["charging_type"] = g.ChargingType
	g.fieldMap["cycle"] = g.Cycle
	g.fieldMap["amount"] = g.Amount
	g.fieldMap["limiter"] = g.Limiter
	g.fieldMap["r_limiter"] = g.RLimiter
	g.fieldMap["c_limiter"] = g.CLimiter
	g.fieldMap["exp_at"] = g.ExpAt

}

func (g gostClientHost) clone(db *gorm.DB) gostClientHost {
	g.gostClientHostDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g gostClientHost) replaceDB(db *gorm.DB) gostClientHost {
	g.gostClientHostDo.ReplaceDB(db)
	return g
}

type gostClientHostBelongsToNode struct {
	db *gorm.DB

	field.RelationField

	Configs struct {
		field.RelationField
		Node struct {
			field.RelationField
		}
	}
}

func (a gostClientHostBelongsToNode) Where(conds ...field.Expr) *gostClientHostBelongsToNode {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a gostClientHostBelongsToNode) WithContext(ctx context.Context) *gostClientHostBelongsToNode {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a gostClientHostBelongsToNode) Session(session *gorm.Session) *gostClientHostBelongsToNode {
	a.db = a.db.Session(session)
	return &a
}

func (a gostClientHostBelongsToNode) Model(m *model.GostClientHost) *gostClientHostBelongsToNodeTx {
	return &gostClientHostBelongsToNodeTx{a.db.Model(m).Association(a.Name())}
}

type gostClientHostBelongsToNodeTx struct{ tx *gorm.Association }

func (a gostClientHostBelongsToNodeTx) Find() (result *model.GostNode, err error) {
	return result, a.tx.Find(&result)
}

func (a gostClientHostBelongsToNodeTx) Append(values ...*model.GostNode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a gostClientHostBelongsToNodeTx) Replace(values ...*model.GostNode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a gostClientHostBelongsToNodeTx) Delete(values ...*model.GostNode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a gostClientHostBelongsToNodeTx) Clear() error {
	return a.tx.Clear()
}

func (a gostClientHostBelongsToNodeTx) Count() int64 {
	return a.tx.Count()
}

type gostClientHostBelongsToClient struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
		BindEmail struct {
			field.RelationField
		}
	}
}

func (a gostClientHostBelongsToClient) Where(conds ...field.Expr) *gostClientHostBelongsToClient {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a gostClientHostBelongsToClient) WithContext(ctx context.Context) *gostClientHostBelongsToClient {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a gostClientHostBelongsToClient) Session(session *gorm.Session) *gostClientHostBelongsToClient {
	a.db = a.db.Session(session)
	return &a
}

func (a gostClientHostBelongsToClient) Model(m *model.GostClientHost) *gostClientHostBelongsToClientTx {
	return &gostClientHostBelongsToClientTx{a.db.Model(m).Association(a.Name())}
}

type gostClientHostBelongsToClientTx struct{ tx *gorm.Association }

func (a gostClientHostBelongsToClientTx) Find() (result *model.GostClient, err error) {
	return result, a.tx.Find(&result)
}

func (a gostClientHostBelongsToClientTx) Append(values ...*model.GostClient) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a gostClientHostBelongsToClientTx) Replace(values ...*model.GostClient) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a gostClientHostBelongsToClientTx) Delete(values ...*model.GostClient) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a gostClientHostBelongsToClientTx) Clear() error {
	return a.tx.Clear()
}

func (a gostClientHostBelongsToClientTx) Count() int64 {
	return a.tx.Count()
}

type gostClientHostBelongsToUser struct {
	db *gorm.DB

	field.RelationField
}

func (a gostClientHostBelongsToUser) Where(conds ...field.Expr) *gostClientHostBelongsToUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a gostClientHostBelongsToUser) WithContext(ctx context.Context) *gostClientHostBelongsToUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a gostClientHostBelongsToUser) Session(session *gorm.Session) *gostClientHostBelongsToUser {
	a.db = a.db.Session(session)
	return &a
}

func (a gostClientHostBelongsToUser) Model(m *model.GostClientHost) *gostClientHostBelongsToUserTx {
	return &gostClientHostBelongsToUserTx{a.db.Model(m).Association(a.Name())}
}

type gostClientHostBelongsToUserTx struct{ tx *gorm.Association }

func (a gostClientHostBelongsToUserTx) Find() (result *model.SystemUser, err error) {
	return result, a.tx.Find(&result)
}

func (a gostClientHostBelongsToUserTx) Append(values ...*model.SystemUser) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a gostClientHostBelongsToUserTx) Replace(values ...*model.SystemUser) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a gostClientHostBelongsToUserTx) Delete(values ...*model.SystemUser) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a gostClientHostBelongsToUserTx) Clear() error {
	return a.tx.Clear()
}

func (a gostClientHostBelongsToUserTx) Count() int64 {
	return a.tx.Count()
}

type gostClientHostDo struct{ gen.DO }

type IGostClientHostDo interface {
	gen.SubQuery
	Debug() IGostClientHostDo
	WithContext(ctx context.Context) IGostClientHostDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGostClientHostDo
	WriteDB() IGostClientHostDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGostClientHostDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGostClientHostDo
	Not(conds ...gen.Condition) IGostClientHostDo
	Or(conds ...gen.Condition) IGostClientHostDo
	Select(conds ...field.Expr) IGostClientHostDo
	Where(conds ...gen.Condition) IGostClientHostDo
	Order(conds ...field.Expr) IGostClientHostDo
	Distinct(cols ...field.Expr) IGostClientHostDo
	Omit(cols ...field.Expr) IGostClientHostDo
	Join(table schema.Tabler, on ...field.Expr) IGostClientHostDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGostClientHostDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGostClientHostDo
	Group(cols ...field.Expr) IGostClientHostDo
	Having(conds ...gen.Condition) IGostClientHostDo
	Limit(limit int) IGostClientHostDo
	Offset(offset int) IGostClientHostDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGostClientHostDo
	Unscoped() IGostClientHostDo
	Create(values ...*model.GostClientHost) error
	CreateInBatches(values []*model.GostClientHost, batchSize int) error
	Save(values ...*model.GostClientHost) error
	First() (*model.GostClientHost, error)
	Take() (*model.GostClientHost, error)
	Last() (*model.GostClientHost, error)
	Find() ([]*model.GostClientHost, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GostClientHost, err error)
	FindInBatches(result *[]*model.GostClientHost, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GostClientHost) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGostClientHostDo
	Assign(attrs ...field.AssignExpr) IGostClientHostDo
	Joins(fields ...field.RelationField) IGostClientHostDo
	Preload(fields ...field.RelationField) IGostClientHostDo
	FirstOrInit() (*model.GostClientHost, error)
	FirstOrCreate() (*model.GostClientHost, error)
	FindByPage(offset int, limit int) (result []*model.GostClientHost, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGostClientHostDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g gostClientHostDo) Debug() IGostClientHostDo {
	return g.withDO(g.DO.Debug())
}

func (g gostClientHostDo) WithContext(ctx context.Context) IGostClientHostDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gostClientHostDo) ReadDB() IGostClientHostDo {
	return g.Clauses(dbresolver.Read)
}

func (g gostClientHostDo) WriteDB() IGostClientHostDo {
	return g.Clauses(dbresolver.Write)
}

func (g gostClientHostDo) Session(config *gorm.Session) IGostClientHostDo {
	return g.withDO(g.DO.Session(config))
}

func (g gostClientHostDo) Clauses(conds ...clause.Expression) IGostClientHostDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gostClientHostDo) Returning(value interface{}, columns ...string) IGostClientHostDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gostClientHostDo) Not(conds ...gen.Condition) IGostClientHostDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gostClientHostDo) Or(conds ...gen.Condition) IGostClientHostDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gostClientHostDo) Select(conds ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gostClientHostDo) Where(conds ...gen.Condition) IGostClientHostDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gostClientHostDo) Order(conds ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gostClientHostDo) Distinct(cols ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gostClientHostDo) Omit(cols ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gostClientHostDo) Join(table schema.Tabler, on ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gostClientHostDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gostClientHostDo) RightJoin(table schema.Tabler, on ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gostClientHostDo) Group(cols ...field.Expr) IGostClientHostDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gostClientHostDo) Having(conds ...gen.Condition) IGostClientHostDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gostClientHostDo) Limit(limit int) IGostClientHostDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gostClientHostDo) Offset(offset int) IGostClientHostDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gostClientHostDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGostClientHostDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gostClientHostDo) Unscoped() IGostClientHostDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gostClientHostDo) Create(values ...*model.GostClientHost) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gostClientHostDo) CreateInBatches(values []*model.GostClientHost, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gostClientHostDo) Save(values ...*model.GostClientHost) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gostClientHostDo) First() (*model.GostClientHost, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientHost), nil
	}
}

func (g gostClientHostDo) Take() (*model.GostClientHost, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientHost), nil
	}
}

func (g gostClientHostDo) Last() (*model.GostClientHost, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientHost), nil
	}
}

func (g gostClientHostDo) Find() ([]*model.GostClientHost, error) {
	result, err := g.DO.Find()
	return result.([]*model.GostClientHost), err
}

func (g gostClientHostDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GostClientHost, err error) {
	buf := make([]*model.GostClientHost, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gostClientHostDo) FindInBatches(result *[]*model.GostClientHost, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gostClientHostDo) Attrs(attrs ...field.AssignExpr) IGostClientHostDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gostClientHostDo) Assign(attrs ...field.AssignExpr) IGostClientHostDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gostClientHostDo) Joins(fields ...field.RelationField) IGostClientHostDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gostClientHostDo) Preload(fields ...field.RelationField) IGostClientHostDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gostClientHostDo) FirstOrInit() (*model.GostClientHost, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientHost), nil
	}
}

func (g gostClientHostDo) FirstOrCreate() (*model.GostClientHost, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientHost), nil
	}
}

func (g gostClientHostDo) FindByPage(offset int, limit int) (result []*model.GostClientHost, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gostClientHostDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g gostClientHostDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g gostClientHostDo) Delete(models ...*model.GostClientHost) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *gostClientHostDo) withDO(do gen.Dao) *gostClientHostDo {
	g.DO = *do.(*gen.DO)
	return g
}
