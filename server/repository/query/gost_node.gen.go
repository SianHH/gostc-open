// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"server/model"
)

func newGostNode(db *gorm.DB, opts ...gen.DOOption) gostNode {
	_gostNode := gostNode{}

	_gostNode.gostNodeDo.UseDB(db, opts...)
	_gostNode.gostNodeDo.UseModel(&model.GostNode{})

	tableName := _gostNode.gostNodeDo.TableName()
	_gostNode.ALL = field.NewAsterisk(tableName)
	_gostNode.Id = field.NewInt(tableName, "id")
	_gostNode.Code = field.NewString(tableName, "code")
	_gostNode.AllowEdit = field.NewInt(tableName, "allow_edit")
	_gostNode.AllowDel = field.NewInt(tableName, "allow_del")
	_gostNode.Version = field.NewInt64(tableName, "version")
	_gostNode.CreatedAt = field.NewTime(tableName, "created_at")
	_gostNode.UpdatedAt = field.NewTime(tableName, "updated_at")
	_gostNode.IndexValue = field.NewInt(tableName, "index_value")
	_gostNode.Key = field.NewString(tableName, "key")
	_gostNode.Name = field.NewString(tableName, "name")
	_gostNode.Remark = field.NewString(tableName, "remark")
	_gostNode.Web = field.NewInt(tableName, "web")
	_gostNode.Tunnel = field.NewInt(tableName, "tunnel")
	_gostNode.Forward = field.NewInt(tableName, "forward")
	_gostNode.Proxy = field.NewInt(tableName, "proxy")
	_gostNode.P2P = field.NewInt(tableName, "p2p")
	_gostNode.Domain = field.NewString(tableName, "domain")
	_gostNode.DenyDomainPrefix = field.NewString(tableName, "deny_domain_prefix")
	_gostNode.UrlTpl = field.NewString(tableName, "url_tpl")
	_gostNode.Address = field.NewString(tableName, "address")
	_gostNode.Protocol = field.NewString(tableName, "protocol")
	_gostNode.TunnelConnPort = field.NewString(tableName, "tunnel_conn_port")
	_gostNode.TunnelInPort = field.NewString(tableName, "tunnel_in_port")
	_gostNode.TunnelMetadata = field.NewString(tableName, "tunnel_metadata")
	_gostNode.TunnelReplaceAddress = field.NewString(tableName, "tunnel_replace_address")
	_gostNode.ForwardConnPort = field.NewString(tableName, "forward_conn_port")
	_gostNode.ForwardPorts = field.NewString(tableName, "forward_ports")
	_gostNode.ForwardMetadata = field.NewString(tableName, "forward_metadata")
	_gostNode.ForwardReplaceAddress = field.NewString(tableName, "forward_replace_address")
	_gostNode.P2PPort = field.NewString(tableName, "p2p_port")
	_gostNode.P2PDisableForward = field.NewInt(tableName, "p2p_disable_forward")
	_gostNode.Rules = field.NewString(tableName, "rules")
	_gostNode.Tags = field.NewString(tableName, "tags")
	_gostNode.LimitResetIndex = field.NewInt(tableName, "limit_reset_index")
	_gostNode.LimitTotal = field.NewInt(tableName, "limit_total")
	_gostNode.LimitKind = field.NewInt(tableName, "limit_kind")
	_gostNode.Configs = gostNodeHasManyConfigs{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Configs", "model.GostNodeConfig"),
		Node: struct {
			field.RelationField
			Configs struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Configs.Node", "model.GostNode"),
			Configs: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Configs.Node.Configs", "model.GostNodeConfig"),
			},
		},
	}

	_gostNode.fillFieldMap()

	return _gostNode
}

type gostNode struct {
	gostNodeDo

	ALL                   field.Asterisk
	Id                    field.Int
	Code                  field.String
	AllowEdit             field.Int
	AllowDel              field.Int
	Version               field.Int64
	CreatedAt             field.Time
	UpdatedAt             field.Time
	IndexValue            field.Int
	Key                   field.String
	Name                  field.String
	Remark                field.String
	Web                   field.Int
	Tunnel                field.Int
	Forward               field.Int
	Proxy                 field.Int
	P2P                   field.Int
	Domain                field.String
	DenyDomainPrefix      field.String
	UrlTpl                field.String
	Address               field.String
	Protocol              field.String
	TunnelConnPort        field.String
	TunnelInPort          field.String
	TunnelMetadata        field.String
	TunnelReplaceAddress  field.String
	ForwardConnPort       field.String
	ForwardPorts          field.String
	ForwardMetadata       field.String
	ForwardReplaceAddress field.String
	P2PPort               field.String
	P2PDisableForward     field.Int
	Rules                 field.String
	Tags                  field.String
	LimitResetIndex       field.Int
	LimitTotal            field.Int
	LimitKind             field.Int
	Configs               gostNodeHasManyConfigs

	fieldMap map[string]field.Expr
}

func (g gostNode) Table(newTableName string) *gostNode {
	g.gostNodeDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gostNode) As(alias string) *gostNode {
	g.gostNodeDo.DO = *(g.gostNodeDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gostNode) updateTableName(table string) *gostNode {
	g.ALL = field.NewAsterisk(table)
	g.Id = field.NewInt(table, "id")
	g.Code = field.NewString(table, "code")
	g.AllowEdit = field.NewInt(table, "allow_edit")
	g.AllowDel = field.NewInt(table, "allow_del")
	g.Version = field.NewInt64(table, "version")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")
	g.IndexValue = field.NewInt(table, "index_value")
	g.Key = field.NewString(table, "key")
	g.Name = field.NewString(table, "name")
	g.Remark = field.NewString(table, "remark")
	g.Web = field.NewInt(table, "web")
	g.Tunnel = field.NewInt(table, "tunnel")
	g.Forward = field.NewInt(table, "forward")
	g.Proxy = field.NewInt(table, "proxy")
	g.P2P = field.NewInt(table, "p2p")
	g.Domain = field.NewString(table, "domain")
	g.DenyDomainPrefix = field.NewString(table, "deny_domain_prefix")
	g.UrlTpl = field.NewString(table, "url_tpl")
	g.Address = field.NewString(table, "address")
	g.Protocol = field.NewString(table, "protocol")
	g.TunnelConnPort = field.NewString(table, "tunnel_conn_port")
	g.TunnelInPort = field.NewString(table, "tunnel_in_port")
	g.TunnelMetadata = field.NewString(table, "tunnel_metadata")
	g.TunnelReplaceAddress = field.NewString(table, "tunnel_replace_address")
	g.ForwardConnPort = field.NewString(table, "forward_conn_port")
	g.ForwardPorts = field.NewString(table, "forward_ports")
	g.ForwardMetadata = field.NewString(table, "forward_metadata")
	g.ForwardReplaceAddress = field.NewString(table, "forward_replace_address")
	g.P2PPort = field.NewString(table, "p2p_port")
	g.P2PDisableForward = field.NewInt(table, "p2p_disable_forward")
	g.Rules = field.NewString(table, "rules")
	g.Tags = field.NewString(table, "tags")
	g.LimitResetIndex = field.NewInt(table, "limit_reset_index")
	g.LimitTotal = field.NewInt(table, "limit_total")
	g.LimitKind = field.NewInt(table, "limit_kind")

	g.fillFieldMap()

	return g
}

func (g *gostNode) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gostNode) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 37)
	g.fieldMap["id"] = g.Id
	g.fieldMap["code"] = g.Code
	g.fieldMap["allow_edit"] = g.AllowEdit
	g.fieldMap["allow_del"] = g.AllowDel
	g.fieldMap["version"] = g.Version
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
	g.fieldMap["index_value"] = g.IndexValue
	g.fieldMap["key"] = g.Key
	g.fieldMap["name"] = g.Name
	g.fieldMap["remark"] = g.Remark
	g.fieldMap["web"] = g.Web
	g.fieldMap["tunnel"] = g.Tunnel
	g.fieldMap["forward"] = g.Forward
	g.fieldMap["proxy"] = g.Proxy
	g.fieldMap["p2p"] = g.P2P
	g.fieldMap["domain"] = g.Domain
	g.fieldMap["deny_domain_prefix"] = g.DenyDomainPrefix
	g.fieldMap["url_tpl"] = g.UrlTpl
	g.fieldMap["address"] = g.Address
	g.fieldMap["protocol"] = g.Protocol
	g.fieldMap["tunnel_conn_port"] = g.TunnelConnPort
	g.fieldMap["tunnel_in_port"] = g.TunnelInPort
	g.fieldMap["tunnel_metadata"] = g.TunnelMetadata
	g.fieldMap["tunnel_replace_address"] = g.TunnelReplaceAddress
	g.fieldMap["forward_conn_port"] = g.ForwardConnPort
	g.fieldMap["forward_ports"] = g.ForwardPorts
	g.fieldMap["forward_metadata"] = g.ForwardMetadata
	g.fieldMap["forward_replace_address"] = g.ForwardReplaceAddress
	g.fieldMap["p2p_port"] = g.P2PPort
	g.fieldMap["p2p_disable_forward"] = g.P2PDisableForward
	g.fieldMap["rules"] = g.Rules
	g.fieldMap["tags"] = g.Tags
	g.fieldMap["limit_reset_index"] = g.LimitResetIndex
	g.fieldMap["limit_total"] = g.LimitTotal
	g.fieldMap["limit_kind"] = g.LimitKind

}

func (g gostNode) clone(db *gorm.DB) gostNode {
	g.gostNodeDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g gostNode) replaceDB(db *gorm.DB) gostNode {
	g.gostNodeDo.ReplaceDB(db)
	return g
}

type gostNodeHasManyConfigs struct {
	db *gorm.DB

	field.RelationField

	Node struct {
		field.RelationField
		Configs struct {
			field.RelationField
		}
	}
}

func (a gostNodeHasManyConfigs) Where(conds ...field.Expr) *gostNodeHasManyConfigs {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a gostNodeHasManyConfigs) WithContext(ctx context.Context) *gostNodeHasManyConfigs {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a gostNodeHasManyConfigs) Session(session *gorm.Session) *gostNodeHasManyConfigs {
	a.db = a.db.Session(session)
	return &a
}

func (a gostNodeHasManyConfigs) Model(m *model.GostNode) *gostNodeHasManyConfigsTx {
	return &gostNodeHasManyConfigsTx{a.db.Model(m).Association(a.Name())}
}

type gostNodeHasManyConfigsTx struct{ tx *gorm.Association }

func (a gostNodeHasManyConfigsTx) Find() (result []*model.GostNodeConfig, err error) {
	return result, a.tx.Find(&result)
}

func (a gostNodeHasManyConfigsTx) Append(values ...*model.GostNodeConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a gostNodeHasManyConfigsTx) Replace(values ...*model.GostNodeConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a gostNodeHasManyConfigsTx) Delete(values ...*model.GostNodeConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a gostNodeHasManyConfigsTx) Clear() error {
	return a.tx.Clear()
}

func (a gostNodeHasManyConfigsTx) Count() int64 {
	return a.tx.Count()
}

type gostNodeDo struct{ gen.DO }

type IGostNodeDo interface {
	gen.SubQuery
	Debug() IGostNodeDo
	WithContext(ctx context.Context) IGostNodeDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGostNodeDo
	WriteDB() IGostNodeDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGostNodeDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGostNodeDo
	Not(conds ...gen.Condition) IGostNodeDo
	Or(conds ...gen.Condition) IGostNodeDo
	Select(conds ...field.Expr) IGostNodeDo
	Where(conds ...gen.Condition) IGostNodeDo
	Order(conds ...field.Expr) IGostNodeDo
	Distinct(cols ...field.Expr) IGostNodeDo
	Omit(cols ...field.Expr) IGostNodeDo
	Join(table schema.Tabler, on ...field.Expr) IGostNodeDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGostNodeDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGostNodeDo
	Group(cols ...field.Expr) IGostNodeDo
	Having(conds ...gen.Condition) IGostNodeDo
	Limit(limit int) IGostNodeDo
	Offset(offset int) IGostNodeDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGostNodeDo
	Unscoped() IGostNodeDo
	Create(values ...*model.GostNode) error
	CreateInBatches(values []*model.GostNode, batchSize int) error
	Save(values ...*model.GostNode) error
	First() (*model.GostNode, error)
	Take() (*model.GostNode, error)
	Last() (*model.GostNode, error)
	Find() ([]*model.GostNode, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GostNode, err error)
	FindInBatches(result *[]*model.GostNode, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GostNode) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGostNodeDo
	Assign(attrs ...field.AssignExpr) IGostNodeDo
	Joins(fields ...field.RelationField) IGostNodeDo
	Preload(fields ...field.RelationField) IGostNodeDo
	FirstOrInit() (*model.GostNode, error)
	FirstOrCreate() (*model.GostNode, error)
	FindByPage(offset int, limit int) (result []*model.GostNode, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGostNodeDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g gostNodeDo) Debug() IGostNodeDo {
	return g.withDO(g.DO.Debug())
}

func (g gostNodeDo) WithContext(ctx context.Context) IGostNodeDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gostNodeDo) ReadDB() IGostNodeDo {
	return g.Clauses(dbresolver.Read)
}

func (g gostNodeDo) WriteDB() IGostNodeDo {
	return g.Clauses(dbresolver.Write)
}

func (g gostNodeDo) Session(config *gorm.Session) IGostNodeDo {
	return g.withDO(g.DO.Session(config))
}

func (g gostNodeDo) Clauses(conds ...clause.Expression) IGostNodeDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gostNodeDo) Returning(value interface{}, columns ...string) IGostNodeDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gostNodeDo) Not(conds ...gen.Condition) IGostNodeDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gostNodeDo) Or(conds ...gen.Condition) IGostNodeDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gostNodeDo) Select(conds ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gostNodeDo) Where(conds ...gen.Condition) IGostNodeDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gostNodeDo) Order(conds ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gostNodeDo) Distinct(cols ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gostNodeDo) Omit(cols ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gostNodeDo) Join(table schema.Tabler, on ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gostNodeDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gostNodeDo) RightJoin(table schema.Tabler, on ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gostNodeDo) Group(cols ...field.Expr) IGostNodeDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gostNodeDo) Having(conds ...gen.Condition) IGostNodeDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gostNodeDo) Limit(limit int) IGostNodeDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gostNodeDo) Offset(offset int) IGostNodeDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gostNodeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGostNodeDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gostNodeDo) Unscoped() IGostNodeDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gostNodeDo) Create(values ...*model.GostNode) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gostNodeDo) CreateInBatches(values []*model.GostNode, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gostNodeDo) Save(values ...*model.GostNode) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gostNodeDo) First() (*model.GostNode, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostNode), nil
	}
}

func (g gostNodeDo) Take() (*model.GostNode, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostNode), nil
	}
}

func (g gostNodeDo) Last() (*model.GostNode, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostNode), nil
	}
}

func (g gostNodeDo) Find() ([]*model.GostNode, error) {
	result, err := g.DO.Find()
	return result.([]*model.GostNode), err
}

func (g gostNodeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GostNode, err error) {
	buf := make([]*model.GostNode, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gostNodeDo) FindInBatches(result *[]*model.GostNode, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gostNodeDo) Attrs(attrs ...field.AssignExpr) IGostNodeDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gostNodeDo) Assign(attrs ...field.AssignExpr) IGostNodeDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gostNodeDo) Joins(fields ...field.RelationField) IGostNodeDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gostNodeDo) Preload(fields ...field.RelationField) IGostNodeDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gostNodeDo) FirstOrInit() (*model.GostNode, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostNode), nil
	}
}

func (g gostNodeDo) FirstOrCreate() (*model.GostNode, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostNode), nil
	}
}

func (g gostNodeDo) FindByPage(offset int, limit int) (result []*model.GostNode, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gostNodeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g gostNodeDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g gostNodeDo) Delete(models ...*model.GostNode) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *gostNodeDo) withDO(do gen.Dao) *gostNodeDo {
	g.DO = *do.(*gen.DO)
	return g
}
