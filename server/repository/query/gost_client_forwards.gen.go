// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"server/model"
)

func newGostClientForward(db *gorm.DB, opts ...gen.DOOption) gostClientForward {
	_gostClientForward := gostClientForward{}

	_gostClientForward.gostClientForwardDo.UseDB(db, opts...)
	_gostClientForward.gostClientForwardDo.UseModel(&model.GostClientForward{})

	tableName := _gostClientForward.gostClientForwardDo.TableName()
	_gostClientForward.ALL = field.NewAsterisk(tableName)
	_gostClientForward.Id = field.NewInt(tableName, "id")
	_gostClientForward.Code = field.NewString(tableName, "code")
	_gostClientForward.AllowEdit = field.NewInt(tableName, "allow_edit")
	_gostClientForward.AllowDel = field.NewInt(tableName, "allow_del")
	_gostClientForward.Version = field.NewInt64(tableName, "version")
	_gostClientForward.CreatedAt = field.NewTime(tableName, "created_at")
	_gostClientForward.UpdatedAt = field.NewTime(tableName, "updated_at")
	_gostClientForward.Name = field.NewString(tableName, "name")
	_gostClientForward.TargetIp = field.NewString(tableName, "target_ip")
	_gostClientForward.TargetPort = field.NewString(tableName, "target_port")
	_gostClientForward.Port = field.NewString(tableName, "port")
	_gostClientForward.ProxyProtocol = field.NewInt(tableName, "proxy_protocol")
	_gostClientForward.NodeCode = field.NewString(tableName, "node_code")
	_gostClientForward.ClientCode = field.NewString(tableName, "client_code")
	_gostClientForward.UserCode = field.NewString(tableName, "user_code")
	_gostClientForward.Enable = field.NewInt(tableName, "enable")
	_gostClientForward.Status = field.NewInt(tableName, "status")
	_gostClientForward.MatcherEnable = field.NewInt(tableName, "matcher_enable")
	_gostClientForward.Matcher = field.NewString(tableName, "matcher")
	_gostClientForward.TcpMatcher = field.NewString(tableName, "tcp_matcher")
	_gostClientForward.SSHMatcher = field.NewString(tableName, "ssh_matcher")
	_gostClientForward.UseEncryption = field.NewInt(tableName, "use_encryption")
	_gostClientForward.UseCompression = field.NewInt(tableName, "use_compression")
	_gostClientForward.WhiteEnable = field.NewInt(tableName, "white_enable")
	_gostClientForward.WhiteList = field.NewString(tableName, "white_list")
	_gostClientForward.ChargingType = field.NewInt(tableName, "charging_type")
	_gostClientForward.Cycle = field.NewInt(tableName, "cycle")
	_gostClientForward.Amount = field.NewField(tableName, "amount")
	_gostClientForward.Limiter = field.NewInt(tableName, "limiter")
	_gostClientForward.RLimiter = field.NewInt(tableName, "r_limiter")
	_gostClientForward.CLimiter = field.NewInt(tableName, "c_limiter")
	_gostClientForward.ExpAt = field.NewInt64(tableName, "exp_at")
	_gostClientForward.Node = gostClientForwardBelongsToNode{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Node", "model.GostNode"),
		Configs: struct {
			field.RelationField
			Node struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Node.Configs", "model.GostNodeConfig"),
			Node: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Node.Configs.Node", "model.GostNode"),
			},
		},
	}

	_gostClientForward.Client = gostClientForwardBelongsToClient{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Client", "model.GostClient"),
		User: struct {
			field.RelationField
			BindEmail struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Client.User", "model.SystemUser"),
			BindEmail: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Client.User.BindEmail", "model.SystemUserEmail"),
			},
		},
	}

	_gostClientForward.User = gostClientForwardBelongsToUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "model.SystemUser"),
	}

	_gostClientForward.fillFieldMap()

	return _gostClientForward
}

type gostClientForward struct {
	gostClientForwardDo

	ALL            field.Asterisk
	Id             field.Int
	Code           field.String
	AllowEdit      field.Int
	AllowDel       field.Int
	Version        field.Int64
	CreatedAt      field.Time
	UpdatedAt      field.Time
	Name           field.String
	TargetIp       field.String
	TargetPort     field.String
	Port           field.String
	ProxyProtocol  field.Int
	NodeCode       field.String
	ClientCode     field.String
	UserCode       field.String
	Enable         field.Int
	Status         field.Int
	MatcherEnable  field.Int
	Matcher        field.String
	TcpMatcher     field.String
	SSHMatcher     field.String
	UseEncryption  field.Int
	UseCompression field.Int
	WhiteEnable    field.Int
	WhiteList      field.String
	ChargingType   field.Int
	Cycle          field.Int
	Amount         field.Field
	Limiter        field.Int
	RLimiter       field.Int
	CLimiter       field.Int
	ExpAt          field.Int64
	Node           gostClientForwardBelongsToNode

	Client gostClientForwardBelongsToClient

	User gostClientForwardBelongsToUser

	fieldMap map[string]field.Expr
}

func (g gostClientForward) Table(newTableName string) *gostClientForward {
	g.gostClientForwardDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gostClientForward) As(alias string) *gostClientForward {
	g.gostClientForwardDo.DO = *(g.gostClientForwardDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gostClientForward) updateTableName(table string) *gostClientForward {
	g.ALL = field.NewAsterisk(table)
	g.Id = field.NewInt(table, "id")
	g.Code = field.NewString(table, "code")
	g.AllowEdit = field.NewInt(table, "allow_edit")
	g.AllowDel = field.NewInt(table, "allow_del")
	g.Version = field.NewInt64(table, "version")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")
	g.Name = field.NewString(table, "name")
	g.TargetIp = field.NewString(table, "target_ip")
	g.TargetPort = field.NewString(table, "target_port")
	g.Port = field.NewString(table, "port")
	g.ProxyProtocol = field.NewInt(table, "proxy_protocol")
	g.NodeCode = field.NewString(table, "node_code")
	g.ClientCode = field.NewString(table, "client_code")
	g.UserCode = field.NewString(table, "user_code")
	g.Enable = field.NewInt(table, "enable")
	g.Status = field.NewInt(table, "status")
	g.MatcherEnable = field.NewInt(table, "matcher_enable")
	g.Matcher = field.NewString(table, "matcher")
	g.TcpMatcher = field.NewString(table, "tcp_matcher")
	g.SSHMatcher = field.NewString(table, "ssh_matcher")
	g.UseEncryption = field.NewInt(table, "use_encryption")
	g.UseCompression = field.NewInt(table, "use_compression")
	g.WhiteEnable = field.NewInt(table, "white_enable")
	g.WhiteList = field.NewString(table, "white_list")
	g.ChargingType = field.NewInt(table, "charging_type")
	g.Cycle = field.NewInt(table, "cycle")
	g.Amount = field.NewField(table, "amount")
	g.Limiter = field.NewInt(table, "limiter")
	g.RLimiter = field.NewInt(table, "r_limiter")
	g.CLimiter = field.NewInt(table, "c_limiter")
	g.ExpAt = field.NewInt64(table, "exp_at")

	g.fillFieldMap()

	return g
}

func (g *gostClientForward) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gostClientForward) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 35)
	g.fieldMap["id"] = g.Id
	g.fieldMap["code"] = g.Code
	g.fieldMap["allow_edit"] = g.AllowEdit
	g.fieldMap["allow_del"] = g.AllowDel
	g.fieldMap["version"] = g.Version
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
	g.fieldMap["name"] = g.Name
	g.fieldMap["target_ip"] = g.TargetIp
	g.fieldMap["target_port"] = g.TargetPort
	g.fieldMap["port"] = g.Port
	g.fieldMap["proxy_protocol"] = g.ProxyProtocol
	g.fieldMap["node_code"] = g.NodeCode
	g.fieldMap["client_code"] = g.ClientCode
	g.fieldMap["user_code"] = g.UserCode
	g.fieldMap["enable"] = g.Enable
	g.fieldMap["status"] = g.Status
	g.fieldMap["matcher_enable"] = g.MatcherEnable
	g.fieldMap["matcher"] = g.Matcher
	g.fieldMap["tcp_matcher"] = g.TcpMatcher
	g.fieldMap["ssh_matcher"] = g.SSHMatcher
	g.fieldMap["use_encryption"] = g.UseEncryption
	g.fieldMap["use_compression"] = g.UseCompression
	g.fieldMap["white_enable"] = g.WhiteEnable
	g.fieldMap["white_list"] = g.WhiteList
	g.fieldMap["charging_type"] = g.ChargingType
	g.fieldMap["cycle"] = g.Cycle
	g.fieldMap["amount"] = g.Amount
	g.fieldMap["limiter"] = g.Limiter
	g.fieldMap["r_limiter"] = g.RLimiter
	g.fieldMap["c_limiter"] = g.CLimiter
	g.fieldMap["exp_at"] = g.ExpAt

}

func (g gostClientForward) clone(db *gorm.DB) gostClientForward {
	g.gostClientForwardDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g gostClientForward) replaceDB(db *gorm.DB) gostClientForward {
	g.gostClientForwardDo.ReplaceDB(db)
	return g
}

type gostClientForwardBelongsToNode struct {
	db *gorm.DB

	field.RelationField

	Configs struct {
		field.RelationField
		Node struct {
			field.RelationField
		}
	}
}

func (a gostClientForwardBelongsToNode) Where(conds ...field.Expr) *gostClientForwardBelongsToNode {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a gostClientForwardBelongsToNode) WithContext(ctx context.Context) *gostClientForwardBelongsToNode {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a gostClientForwardBelongsToNode) Session(session *gorm.Session) *gostClientForwardBelongsToNode {
	a.db = a.db.Session(session)
	return &a
}

func (a gostClientForwardBelongsToNode) Model(m *model.GostClientForward) *gostClientForwardBelongsToNodeTx {
	return &gostClientForwardBelongsToNodeTx{a.db.Model(m).Association(a.Name())}
}

type gostClientForwardBelongsToNodeTx struct{ tx *gorm.Association }

func (a gostClientForwardBelongsToNodeTx) Find() (result *model.GostNode, err error) {
	return result, a.tx.Find(&result)
}

func (a gostClientForwardBelongsToNodeTx) Append(values ...*model.GostNode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a gostClientForwardBelongsToNodeTx) Replace(values ...*model.GostNode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a gostClientForwardBelongsToNodeTx) Delete(values ...*model.GostNode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a gostClientForwardBelongsToNodeTx) Clear() error {
	return a.tx.Clear()
}

func (a gostClientForwardBelongsToNodeTx) Count() int64 {
	return a.tx.Count()
}

type gostClientForwardBelongsToClient struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
		BindEmail struct {
			field.RelationField
		}
	}
}

func (a gostClientForwardBelongsToClient) Where(conds ...field.Expr) *gostClientForwardBelongsToClient {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a gostClientForwardBelongsToClient) WithContext(ctx context.Context) *gostClientForwardBelongsToClient {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a gostClientForwardBelongsToClient) Session(session *gorm.Session) *gostClientForwardBelongsToClient {
	a.db = a.db.Session(session)
	return &a
}

func (a gostClientForwardBelongsToClient) Model(m *model.GostClientForward) *gostClientForwardBelongsToClientTx {
	return &gostClientForwardBelongsToClientTx{a.db.Model(m).Association(a.Name())}
}

type gostClientForwardBelongsToClientTx struct{ tx *gorm.Association }

func (a gostClientForwardBelongsToClientTx) Find() (result *model.GostClient, err error) {
	return result, a.tx.Find(&result)
}

func (a gostClientForwardBelongsToClientTx) Append(values ...*model.GostClient) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a gostClientForwardBelongsToClientTx) Replace(values ...*model.GostClient) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a gostClientForwardBelongsToClientTx) Delete(values ...*model.GostClient) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a gostClientForwardBelongsToClientTx) Clear() error {
	return a.tx.Clear()
}

func (a gostClientForwardBelongsToClientTx) Count() int64 {
	return a.tx.Count()
}

type gostClientForwardBelongsToUser struct {
	db *gorm.DB

	field.RelationField
}

func (a gostClientForwardBelongsToUser) Where(conds ...field.Expr) *gostClientForwardBelongsToUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a gostClientForwardBelongsToUser) WithContext(ctx context.Context) *gostClientForwardBelongsToUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a gostClientForwardBelongsToUser) Session(session *gorm.Session) *gostClientForwardBelongsToUser {
	a.db = a.db.Session(session)
	return &a
}

func (a gostClientForwardBelongsToUser) Model(m *model.GostClientForward) *gostClientForwardBelongsToUserTx {
	return &gostClientForwardBelongsToUserTx{a.db.Model(m).Association(a.Name())}
}

type gostClientForwardBelongsToUserTx struct{ tx *gorm.Association }

func (a gostClientForwardBelongsToUserTx) Find() (result *model.SystemUser, err error) {
	return result, a.tx.Find(&result)
}

func (a gostClientForwardBelongsToUserTx) Append(values ...*model.SystemUser) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a gostClientForwardBelongsToUserTx) Replace(values ...*model.SystemUser) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a gostClientForwardBelongsToUserTx) Delete(values ...*model.SystemUser) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a gostClientForwardBelongsToUserTx) Clear() error {
	return a.tx.Clear()
}

func (a gostClientForwardBelongsToUserTx) Count() int64 {
	return a.tx.Count()
}

type gostClientForwardDo struct{ gen.DO }

type IGostClientForwardDo interface {
	gen.SubQuery
	Debug() IGostClientForwardDo
	WithContext(ctx context.Context) IGostClientForwardDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGostClientForwardDo
	WriteDB() IGostClientForwardDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGostClientForwardDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGostClientForwardDo
	Not(conds ...gen.Condition) IGostClientForwardDo
	Or(conds ...gen.Condition) IGostClientForwardDo
	Select(conds ...field.Expr) IGostClientForwardDo
	Where(conds ...gen.Condition) IGostClientForwardDo
	Order(conds ...field.Expr) IGostClientForwardDo
	Distinct(cols ...field.Expr) IGostClientForwardDo
	Omit(cols ...field.Expr) IGostClientForwardDo
	Join(table schema.Tabler, on ...field.Expr) IGostClientForwardDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGostClientForwardDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGostClientForwardDo
	Group(cols ...field.Expr) IGostClientForwardDo
	Having(conds ...gen.Condition) IGostClientForwardDo
	Limit(limit int) IGostClientForwardDo
	Offset(offset int) IGostClientForwardDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGostClientForwardDo
	Unscoped() IGostClientForwardDo
	Create(values ...*model.GostClientForward) error
	CreateInBatches(values []*model.GostClientForward, batchSize int) error
	Save(values ...*model.GostClientForward) error
	First() (*model.GostClientForward, error)
	Take() (*model.GostClientForward, error)
	Last() (*model.GostClientForward, error)
	Find() ([]*model.GostClientForward, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GostClientForward, err error)
	FindInBatches(result *[]*model.GostClientForward, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GostClientForward) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGostClientForwardDo
	Assign(attrs ...field.AssignExpr) IGostClientForwardDo
	Joins(fields ...field.RelationField) IGostClientForwardDo
	Preload(fields ...field.RelationField) IGostClientForwardDo
	FirstOrInit() (*model.GostClientForward, error)
	FirstOrCreate() (*model.GostClientForward, error)
	FindByPage(offset int, limit int) (result []*model.GostClientForward, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGostClientForwardDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g gostClientForwardDo) Debug() IGostClientForwardDo {
	return g.withDO(g.DO.Debug())
}

func (g gostClientForwardDo) WithContext(ctx context.Context) IGostClientForwardDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gostClientForwardDo) ReadDB() IGostClientForwardDo {
	return g.Clauses(dbresolver.Read)
}

func (g gostClientForwardDo) WriteDB() IGostClientForwardDo {
	return g.Clauses(dbresolver.Write)
}

func (g gostClientForwardDo) Session(config *gorm.Session) IGostClientForwardDo {
	return g.withDO(g.DO.Session(config))
}

func (g gostClientForwardDo) Clauses(conds ...clause.Expression) IGostClientForwardDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gostClientForwardDo) Returning(value interface{}, columns ...string) IGostClientForwardDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gostClientForwardDo) Not(conds ...gen.Condition) IGostClientForwardDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gostClientForwardDo) Or(conds ...gen.Condition) IGostClientForwardDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gostClientForwardDo) Select(conds ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gostClientForwardDo) Where(conds ...gen.Condition) IGostClientForwardDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gostClientForwardDo) Order(conds ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gostClientForwardDo) Distinct(cols ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gostClientForwardDo) Omit(cols ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gostClientForwardDo) Join(table schema.Tabler, on ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gostClientForwardDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gostClientForwardDo) RightJoin(table schema.Tabler, on ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gostClientForwardDo) Group(cols ...field.Expr) IGostClientForwardDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gostClientForwardDo) Having(conds ...gen.Condition) IGostClientForwardDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gostClientForwardDo) Limit(limit int) IGostClientForwardDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gostClientForwardDo) Offset(offset int) IGostClientForwardDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gostClientForwardDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGostClientForwardDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gostClientForwardDo) Unscoped() IGostClientForwardDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gostClientForwardDo) Create(values ...*model.GostClientForward) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gostClientForwardDo) CreateInBatches(values []*model.GostClientForward, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gostClientForwardDo) Save(values ...*model.GostClientForward) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gostClientForwardDo) First() (*model.GostClientForward, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientForward), nil
	}
}

func (g gostClientForwardDo) Take() (*model.GostClientForward, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientForward), nil
	}
}

func (g gostClientForwardDo) Last() (*model.GostClientForward, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientForward), nil
	}
}

func (g gostClientForwardDo) Find() ([]*model.GostClientForward, error) {
	result, err := g.DO.Find()
	return result.([]*model.GostClientForward), err
}

func (g gostClientForwardDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GostClientForward, err error) {
	buf := make([]*model.GostClientForward, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gostClientForwardDo) FindInBatches(result *[]*model.GostClientForward, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gostClientForwardDo) Attrs(attrs ...field.AssignExpr) IGostClientForwardDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gostClientForwardDo) Assign(attrs ...field.AssignExpr) IGostClientForwardDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gostClientForwardDo) Joins(fields ...field.RelationField) IGostClientForwardDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gostClientForwardDo) Preload(fields ...field.RelationField) IGostClientForwardDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gostClientForwardDo) FirstOrInit() (*model.GostClientForward, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientForward), nil
	}
}

func (g gostClientForwardDo) FirstOrCreate() (*model.GostClientForward, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GostClientForward), nil
	}
}

func (g gostClientForwardDo) FindByPage(offset int, limit int) (result []*model.GostClientForward, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gostClientForwardDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g gostClientForwardDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g gostClientForwardDo) Delete(models ...*model.GostClientForward) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *gostClientForwardDo) withDO(do gen.Dao) *gostClientForwardDo {
	g.DO = *do.(*gen.DO)
	return g
}
